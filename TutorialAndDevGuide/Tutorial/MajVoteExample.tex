\subsection{The Boyer-Moore Majority-Vote Algorithm}
\label{subsec:boyer_moore}

In this section we demonstrate how to use Haskell as an advanced macro language
on top of Copilot by implementing an algorithm for solving the voting problem
in Copilot.

Reliability in mission critical software is often improved by replicating
the same computations on separate hardware and by doing a vote in the end
based on the output of each system. The majority vote problem consists of
determining if in a given list of votes there is a candidate that has more
than half of the votes, and if so, of finding this candidate.

The Boyer-Moore Majority Vote Algorithm \cite{MooreBoyer82,Hesselink2005} solves
the problem in linear time and constant memory. It does so in two passes: The
first pass chooses a candidate; and the second pass asserts that the
found candidate indeed holds a majority.

The algorithm for the first pass involves the sequence of elements given as an input,
a single element that represents the current majority, and a counter,
which is initially set to zero. The algorithm is as follows:
\begin{itemize}
\item Initialize an element $m$ and a counter $i$ where $i=0$
\item For each element x of the input sequence: 
	\begin{itemize} 
	\item If $i=0$ then let $m=x$ and $i=1$
	\item else if $m=x$ then increment $i$
	\item else let $i = i-1$
	\end{itemize}
\item Return $m$
\end{itemize}

This algorithm will produce an output even if there is no majority, which is why 
the second pass is needed to verify that the output of the first pass is valid. 


\lstinputlisting[language = Copilot, numbers = left]{Examples/MajVoteExample.hs}

The first pass can be implemented
in Haskell as shown in lines 2-13. The second pass, which
simply checks that a candidate has more than half of the votes, is
straightforward to implement and is shown in lines 15-23.
E.g. applying {\tt majorityPure} on the string {\tt AAACCBBCCCBCC} yields {\tt
  C}, which {\tt aMajorityPure} can confirm is in fact a majority.

 
\lstinputlisting[language = Copilot, numbers = left]{Examples/VotingImp.hs}

When implementing the majority vote algorithm for Copilot, we can use reuse
almost all of the code from the Haskell implementation. However, as functions
in Copilot are macros that are expanded at compile time, care must
be taken in order to avoid an explosion in the code size. Hence, instead of
using Haskell's built-in \emph{let}-blocks, we use explicit sharing. The Copilot implementations
of the first and the second pass as shown above. Comparing the Haskell implementation
with the Copilot implementation, we see that the code is almost identical,
except for the type signatures and the explicit sharing annotations.


The majority vote algorithm has been implemented into the Copilot libraries. This allows you, the user, to implement the majority vote functionality with a simple function call. An example of this is in the {\tt ./Examples} directory names {\tt MajVoteCopilot.hs} and is shown below.


\lstinputlisting[language = Copilot, numbers = left]{Examples/MajVoteCopilot.hs}

In this example you can see that we pass a stream of booleans determinied by wether the number is divisible by 1, 2, 3, or 4. The output of {\tt majority} is the value that it has determined to be the majority. After a majority has been picked that majority is then passed through {\tt aMajority} to determine if there is actually a majority. From this example you can see that numbers like 2, 3, 9 and 10 did not have a majority because they had two trues and two falses.  
